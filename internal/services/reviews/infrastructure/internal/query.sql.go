// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package internal

import (
	"context"

	"github.com/google/uuid"
)

const findByHospitalId = `-- name: FindByHospitalId :many
SELECT "createdAt", "updatedAt", id, "userId", "hospitalId", content, rating FROM "review" WHERE "hospitalId" = $1
`

func (q *Queries) FindByHospitalId(ctx context.Context, hospitalid uuid.UUID) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, findByHospitalId, hospitalid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID,
			&i.UserId,
			&i.HospitalId,
			&i.Content,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByUserIdAndHospitalId = `-- name: FindByUserIdAndHospitalId :one
SELECT "createdAt", "updatedAt", id, "userId", "hospitalId", content, rating FROM "review" WHERE "userId" = $1 AND "hospitalId" = $2 LIMIT 1
`

type FindByUserIdAndHospitalIdParams struct {
	UserId     uuid.UUID `json:"userId"`
	HospitalId uuid.UUID `json:"hospitalId"`
}

func (q *Queries) FindByUserIdAndHospitalId(ctx context.Context, arg FindByUserIdAndHospitalIdParams) (Review, error) {
	row := q.db.QueryRowContext(ctx, findByUserIdAndHospitalId, arg.UserId, arg.HospitalId)
	var i Review
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID,
		&i.UserId,
		&i.HospitalId,
		&i.Content,
		&i.Rating,
	)
	return i, err
}

const findOne = `-- name: FindOne :one
SELECT "createdAt", "updatedAt", id, "userId", "hospitalId", content, rating FROM "review" WHERE id = $1
`

func (q *Queries) FindOne(ctx context.Context, id uuid.UUID) (Review, error) {
	row := q.db.QueryRowContext(ctx, findOne, id)
	var i Review
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID,
		&i.UserId,
		&i.HospitalId,
		&i.Content,
		&i.Rating,
	)
	return i, err
}

const save = `-- name: Save :one
INSERT INTO "review" (
  "createdAt", "updatedAt", id, "userId", "hospitalId", "content", "rating"
) VALUES (
  NOW(), NOW(), $1, $2, $3, $4, $5
) ON CONFLICT ("id") DO UPDATE
SET 
  "updatedAt" = NOW(),
  "content" = EXCLUDED."content", 
  "rating"=EXCLUDED."rating"
RETURNING "createdAt", "updatedAt", id, "userId", "hospitalId", content, rating
`

type SaveParams struct {
	ID         uuid.UUID `json:"id"`
	UserId     uuid.UUID `json:"userId"`
	HospitalId uuid.UUID `json:"hospitalId"`
	Content    string    `json:"content"`
	Rating     int32     `json:"rating"`
}

func (q *Queries) Save(ctx context.Context, arg SaveParams) (Review, error) {
	row := q.db.QueryRowContext(ctx, save,
		arg.ID,
		arg.UserId,
		arg.HospitalId,
		arg.Content,
		arg.Rating,
	)
	var i Review
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID,
		&i.UserId,
		&i.HospitalId,
		&i.Content,
		&i.Rating,
	)
	return i, err
}
